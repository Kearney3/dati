<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ¬åœ°ç­”é¢˜åº”ç”¨ï¼ˆé«˜çº§ç‰ˆ v7.3 - èƒŒé¢˜æ¨¡å¼ï¼‰</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        /* ADDED: CSSå˜é‡ï¼Œç”¨äºä¸»é¢˜åˆ‡æ¢ */
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --success-color: #1f9e3f;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            
            --bg-gradient-start: #f8f9fa;
            --bg-gradient-end: #e9ecef;
            --container-bg: white;
            --container-shadow: 0 1rem 3rem rgba(0, 0, 0, 0.175);
            --text-color: #343a40;
            --text-color-muted: #6c757d;
            --border-color: #dee2e6;
            --input-bg: #fff;
            --card-bg: #f8f9fa;
            --card-hover-bg: #e9ecef;
        }

        /* ADDED: å¤œé—´æ¨¡å¼çš„å˜é‡å®šä¹‰ */
        body.dark-mode {
            --primary-color: #58a6ff;
            --secondary-color: #8b949e;
            --success-color: #48c15b;
            --danger-color: #f85149;
            --warning-color: #d29922;

            --bg-gradient-start: #0d1117;
            --bg-gradient-end: #161b22;
            --container-bg: #1e242c;
            --container-shadow: 0 1rem 3rem rgba(0, 0, 0, 0.3);
            --text-color: #c9d1d9;
            --text-color-muted: #8b949e;
            --border-color: #30363d;
            --input-bg: #0d1117;
            --card-bg: #21262d;
            --card-hover-bg: #30363d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* MODIFIED: å…¨å±€æ ·å¼ç¾åŒ– */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1.5rem;
            transition: background 0.3s, color 0.3s;
        }

        .container {
            width: 100%;
            max-width: 800px;
            background-color: var(--container-bg);
            border-radius: 20px;
            box-shadow: var(--container-shadow);
            overflow: hidden;
            position: relative; /* ä¸ºä¸»é¢˜åˆ‡æ¢æŒ‰é’®å®šä½ */
            transition: background-color 0.3s, box-shadow 0.3s;
            animation: fadeIn 0.6s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .screen { display: none; padding: 2rem 2.5rem; }
        .screen.active { display: block; }
        
        .theme-switcher {
            position: absolute;
            top: 22px;
            right: 28px;
            cursor: pointer;
            font-size: 1.5rem;
            color: var(--text-color-muted);
            transition: color 0.3s, transform 0.3s;
            z-index: 50; /* ç¡®ä¿åœ¨å†…å®¹ä¹‹ä¸Šï¼Œä½†åœ¨å¼¹çª—ä¹‹ä¸‹ */
        }
        .theme-switcher:hover {
            color: var(--primary-color);
            transform: scale(1.1);
        }

        /* --- é€šç”¨ç»„ä»¶ --- */
        .btn {
            display: inline-block;
            width: 100%;
            padding: 0.85rem 1rem;
            border-radius: 10px;
            font-size: 1.1rem;
            box-sizing: border-box;
            text-align: center;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        .btn-primary { background: linear-gradient(135deg, var(--primary-color) 0%, color-mix(in srgb, var(--primary-color) 70%, #764ba2) 100%); color: white; }
        .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
        .btn-success { background-color: var(--success-color); color: white; }
        .btn-secondary { background-color: var(--secondary-color); color: white; }
        .btn-warning { background-color: var(--warning-color); color: var(--container-bg); }
        .btn-danger { background-color: var(--danger-color); color: white; }
        .btn:disabled { background-color: var(--secondary-color); opacity: 0.5; cursor: not-allowed; }
        
        select, .config-item input[type="text"], .config-item input[type="number"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
            box-sizing: border-box;
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: all 0.3s;
        }
        select:focus, .config-item input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-color) 25%, transparent);
        }

        /* --- é¦–é¡µç¾åŒ– --- */
        #upload-screen h1 {
            font-size: 2.25rem;
            font-weight: 800;
            color: var(--text-color);
            text-align: center;
            margin-bottom: 0.5rem;
        }
        #upload-screen .subtitle {
            text-align: center;
            font-size: 1.1rem;
            color: var(--text-color-muted);
            margin-bottom: 2rem;
        }
        .upload-area {
            border: 2px dashed var(--primary-color);
            border-radius: 12px;
            padding: 2.5rem;
            text-align: center;
            cursor: pointer;
            background-color: transparent;
            transition: all 0.3s;
        }
        .upload-area:hover {
            background-color: color-mix(in srgb, var(--primary-color) 5%, transparent);
            border-color: color-mix(in srgb, var(--primary-color) 70%, #764ba2);
        }
        .upload-icon {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: 1rem;
        }
        #file-name { margin-top: 1rem; color: var(--text-color-muted); font-style: italic; }
        
        #config-panel { margin-top: 2rem; }
        .config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }
        .config-item label, .radio-group-label { display: block; margin-bottom: 0.5rem; font-weight: 500; }
        .radio-group label { margin-right: 1rem; font-weight: normal; }
        .header-mapping-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 1rem;
            align-items: center;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .header-mapping-grid label { white-space: nowrap; }

        /* --- ç­”é¢˜ç•Œé¢åŠå…¶ä»–é¡µé¢æ ·å¼å˜é‡åº”ç”¨ --- */
        #quiz-screen { position: relative; }
        .quiz-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem; }
        .quiz-header-buttons { display: flex; gap: 0.5rem; }
        .quiz-header .btn-sm { padding: 0.4rem 0.8rem; font-size: 0.9rem; width: auto; font-weight: 500; border-radius: 8px; }
        .progress-bar { width: 100%; background-color: var(--border-color); border-radius: 99px; height: 10px; overflow: hidden; margin-top: 0.5rem; }
        #progress-indicator { height: 100%; width: 0; background-color: var(--primary-color); transition: width 0.3s; }
        .question-container { margin-top: 2rem; }
        .question-title { font-size: 1.25rem; font-weight: bold; margin-bottom: 1.5rem; line-height: 1.5; }
        .question-type-badge { font-size: 0.8rem; background-color: var(--secondary-color); color: var(--container-bg); padding: 0.2rem 0.5rem; border-radius: 5px; margin-left: 10px; vertical-align: middle; }
        
        .options-container .option {
            display: block; padding: 0.75rem 1rem; margin-bottom: 0.5rem;
            border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer;
            transition: all 0.2s; background-color: var(--card-bg);
        }
        .options-container .option:hover { background-color: var(--card-hover-bg); border-color: var(--primary-color); }
        .options-container .option input { margin-right: 0.75rem; vertical-align: middle; }

        .fill-in-container { display: flex; flex-direction: column; gap: 0.75rem; }
        .fill-in-container input[type="text"] {
            width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px;
            font-size: 1rem; box-sizing: border-box; background-color: var(--input-bg); color: var(--text-color);
        }
        .quiz-nav { display: flex; justify-content: space-between; margin-top: 2rem; gap: 1rem; }
        .nav-btn { width: 100%; }
        
        .keyboard-shortcuts-hint { text-align: center; color: var(--text-color-muted); font-size: 0.85rem; margin-top: 1.5rem; }

        .feedback-box {
            padding: 1rem; margin-top: 1.5rem; border-radius: 8px;
            border-left-width: 5px; border-left-style: solid;
        }
        .feedback-box p { margin: 0 0 0.5rem 0; }
        .feedback-box.correct { border-color: var(--success-color); background-color: color-mix(in srgb, var(--success-color) 15%, transparent); }
        .feedback-box.incorrect { border-color: var(--danger-color); background-color: color-mix(in srgb, var(--danger-color) 15%, transparent); }
        .feedback-box.hint { border-color: var(--warning-color); background-color: color-mix(in srgb, var(--warning-color) 15%, transparent); }

        .grid-panel { display: grid; grid-template-columns: repeat(auto-fill, minmax(45px, 1fr)); gap: 0.75rem; overflow-y: auto; }
        .grid-btn {
            width: 100%; height: 45px; border: 1px solid var(--border-color); background-color: var(--card-bg);
            color: var(--text-color); cursor: pointer; border-radius: 8px; transition: all 0.2s; font-size: 1rem; position: relative;
        }
        .grid-btn:hover { background-color: var(--card-hover-bg); }
        .grid-btn.answered { background-color: var(--success-color); color: white; border-color: var(--success-color); }
        .grid-btn.current { background-color: var(--primary-color); color: white; border-color: var(--primary-color); transform: scale(1.1); }
        .grid-btn.correct { background-color: var(--success-color); color: white; border-color: var(--success-color); }
        .grid-btn.incorrect { background-color: var(--danger-color); color: white; border-color: var(--danger-color); }

        #nav-panel {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; max-width: 500px; max-height: 70vh; background: var(--container-bg);
            border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            z-index: 1000; padding: 1.5rem; display: none; flex-direction: column;
            border: 1px solid var(--border-color);
        }
        #nav-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        #close-nav-btn { font-size: 1.5rem; cursor: pointer; border: none; background: none; padding: 0; color: var(--text-color); }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); backdrop-filter: blur(5px); z-index: 999; display: none; }

        .results-summary { text-align: center; }
        .score { font-size: 3rem; font-weight: bold; color: var(--primary-color); }
        .accuracy { font-size: 1.5rem; color: var(--text-color-muted); margin-bottom: 2rem; }
        .results-grid-container { margin: 2rem 0; }
        .results-grid-container h3 { text-align: center; margin-bottom: 1rem; }
        .results-actions { display: flex; flex-direction: column; gap: 1rem; }
        
        #review-screen h2 { text-align: center; color: var(--primary-color); }
        #review-filters {
            display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 2rem;
            padding: 0.5rem; background-color: var(--card-bg); border-radius: 12px;
        }
        .filter-group { display: flex; align-items: center; gap: 0.5rem; border-right: 1px solid var(--border-color); padding-right: 1rem; margin-right: 0.5rem; }
        .filter-group:last-child { border-right: none; }
        .tab-filter button {
            padding: 0.5rem 1rem; border: 1px solid transparent; border-radius: 8px;
            background-color: transparent; cursor: pointer; font-size: 0.9rem; transition: all 0.3s; color: var(--text-color);
        }
        .tab-filter button.active { background-color: var(--container-bg); color: var(--primary-color); font-weight: bold; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        
        .review-item {
            border: 1px solid var(--border-color); border-left-width: 5px; border-left-style: solid;
            padding: 1.5rem; margin-bottom: 1.5rem; border-radius: 8px;
        }
        .review-item.review-item-correct { border-left-color: var(--success-color); background-color: color-mix(in srgb, var(--success-color) 15%, transparent); }
        .review-item.review-item-incorrect { border-left-color: var(--danger-color); background-color: color-mix(in srgb, var(--danger-color) 10%, transparent); }
        .review-options-grid { display: flex; flex-direction: column; gap: 0.5rem; margin-top: 1rem; }
        .review-option-card {
            display: flex; align-items: center; padding: 0.75rem; border: 1px solid var(--border-color);
            border-radius: 8px; background-color: var(--input-bg);
        }
        .review-option-card.correct-option { background-color: color-mix(in srgb, var(--success-color) 25%, transparent); }
        .review-option-card.user-selected-incorrect { background-color: color-mix(in srgb, var(--danger-color) 15%, transparent); }
        .review-user-choice-tag {
            margin-left: auto; padding: 0.2rem 0.6rem; font-size: 0.75rem;
            font-weight: bold; color: #fff; background-color: var(--warning-color); border-radius: 99px;
        }
        body.dark-mode .review-user-choice-tag { color: #111; }

        #tooltip {
            position: absolute; display: none; padding: 1rem; background-color: rgba(10, 10, 10, 0.9);
            color: #f0f0f0; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1001; width: 350px; max-width: 90vw; pointer-events: none; font-size: 0.9rem; line-height: 1.5;
            backdrop-filter: blur(5px); border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .tooltip-option-card {
            display: flex; align-items: center; padding: 0.5rem; margin-top: 0.25rem;
            border: 1px solid #555; border-radius: 5px; font-size: 0.85rem;
        }
        .tooltip-option-card.correct-option { border-color: var(--success-color); background-color: color-mix(in srgb, var(--success-color) 20%, #333); }
        .tooltip-option-card.user-selected-incorrect { border-color: var(--danger-color); background-color: color-mix(in srgb, var(--danger-color) 20%, #333); }
        .tooltip-user-choice-tag { font-size: 0.7rem; color: var(--warning-color); margin-left: 1rem; font-weight: bold; }
        
        @media (max-width: 600px) {
            body { padding: 0; align-items: stretch; }
            .container { border-radius: 0; box-shadow: none; min-height: 100vh; margin: 0; }
            .screen { padding: 1.5rem; }
            .config-grid, .header-mapping-grid, #review-filters { grid-template-columns: 1fr; }
            .radio-group { display: flex; flex-wrap: wrap; gap: 0.5rem; }
            .quiz-nav { flex-direction: column; gap: 0.5rem; }
            .nav-btn { width: 100%; }
            .filter-group { border-right: none; padding-right: 0; }
        }
    </style>
</head>
<body>

    <div class="container">
        
        <div id="theme-switcher" class="theme-switcher" title="åˆ‡æ¢æ—¥é—´/å¤œé—´æ¨¡å¼">
            <span id="theme-icon">ğŸŒ™</span>
        </div>

        <div id="upload-screen" class="screen active">
            <h1>æ™ºèƒ½ç­”é¢˜ç³»ç»Ÿ</h1>
            <p class="subtitle">ä¸Šä¼ æ‚¨çš„Excelé¢˜åº“ï¼Œå¼€å¯ä¸ªæ€§åŒ–åˆ·é¢˜ä¹‹æ—…</p>
            
            <div id="upload-area" class="upload-area">
                <div class="upload-icon">ğŸ“</div>
                <p>ç‚¹å‡»æ­¤å¤„æˆ–æ‹–æ‹½Excelé¢˜åº“æ–‡ä»¶åˆ°è¿™é‡Œ</p>
                <p style="font-size: 0.85rem; color: var(--text-color-muted); margin-top: 0.5rem;">Tip: å¡«ç©ºé¢˜ç­”æ¡ˆå¯ç”¨ `|||` åˆ†éš”å¤šä¸ªç©º</p>
                <input type="file" id="file-input" accept=".xlsx, .xls" style="display:none;">
                <p id="file-name"></p>
            </div>

            <div id="config-panel" style="display: none;">
                <div class="config-item">
                    <label for="sheet-select">1. é€‰æ‹©å·¥ä½œè¡¨ (Sheet)</label>
                    <select id="sheet-select"></select>
                </div>

                <div class="header-mapping-grid">
                    <label>2. åŒ¹é…è¡¨å¤´</label>
                    <span>(å°†Excelåˆ—åä¸é¢˜ç›®å±æ€§å¯¹åº”)</span>
                </div>
                <div id="header-mapping" class="header-mapping-grid"></div>

                <div class="config-grid">
                    <div class="config-item" style="grid-column: 1 / -1;">
                        <label class="radio-group-label">3. é€‰æ‹©æ¨¡å¼</label>
                        <div class="radio-group">
                            <label><input type="radio" name="mainMode" value="quiz" checked> ç­”é¢˜æ¨¡å¼</label>
                            <label><input type="radio" name="mainMode" value="review"> å¤ä¹ æ¨¡å¼</label>
                            <label><input type="radio" name="mainMode" value="recite"> èƒŒé¢˜æ¨¡å¼</label>
                        </div>
                    </div>
                    <div class="config-item">
                        <label for="order-mode-select">4. é¢˜ç›®é¡ºåº</label>
                        <select id="order-mode-select">
                            <option value="sequential">é¡ºåºå‡ºé¢˜</option>
                            <option value="random">éšæœºå‡ºé¢˜</option>
                        </select>
                    </div>
                    <div class="config-item">
                        <label for="quiz-limit">5. ç­”é¢˜æ•°é‡ (0ä¸ºä¸é™åˆ¶)</label>
                        <input type="number" id="quiz-limit" value="0" min="0">
                    </div>
                    <div class="config-item" style="grid-column: 1 / -1;">
                        <label>6. åˆ¤æ–­é¢˜é€‰é¡¹</label>
                        <div style="display: flex; gap: 1rem;">
                            <input type="text" id="judgement-true" value="æ­£ç¡®">
                            <input type="text" id="judgement-false" value="é”™è¯¯">
                        </div>
                    </div>
                </div>
                <button id="start-btn" class="btn btn-primary" disabled style="margin-top: 2rem;">å¼€å§‹ç­”é¢˜</button>
            </div>
        </div>

        <div id="quiz-screen" class="screen">
            <div class="quiz-header">
                <span id="progress-text"></span>
                <div class="quiz-header-buttons">
                    <button id="hint-btn" class="btn btn-warning btn-sm">æç¤ºç­”æ¡ˆ</button>
                    <button id="nav-toggle-btn" class="btn btn-secondary btn-sm">é¢˜å·å¯¼èˆª</button>
                    <button id="exit-quiz-btn" class="btn btn-danger btn-sm">é€€å‡º</button>
                </div>
            </div>
            <div class="progress-bar">
                <div id="progress-indicator"></div>
            </div>
            <div class="question-container">
                <p class="question-title">
                    <span id="question-text"></span>
                    <span id="question-type-badge" class="question-type-badge"></span>
                </p>
                <div id="options-container" class="options-container"></div>
                <div id="feedback-box" class="feedback-box" style="display: none;"></div>
            </div>
            <div class="keyboard-shortcuts-hint">
                å¿«æ·é”®ï¼š â† ä¸Šä¸€é¢˜ | â†’ ä¸‹ä¸€é¢˜ | A/B/C... æˆ– 1/2/3... é€‰æ‹©é€‰é¡¹
            </div>
            <div class="quiz-nav">
                <button id="prev-btn" class="btn btn-secondary nav-btn">ä¸Šä¸€é¢˜</button>
                <button id="next-btn" class="btn btn-primary nav-btn">ä¸‹ä¸€é¢˜</button>
                <button id="submit-btn" class="btn btn-success nav-btn" style="display: none;">æäº¤è¯•å·</button>
            </div>
        </div>

        <div id="results-screen" class="screen">
            <div class="results-summary">
                <h2>ç­”é¢˜å®Œæˆï¼</h2>
                <p class="score" id="score"></p>
                <p class="accuracy" id="accuracy"></p>
            </div>
            <div class="results-grid-container">
                <h3>ç­”é¢˜å¡ (æ‚¬æµ®æŸ¥çœ‹è¯¦æƒ…)</h3>
                <div id="results-grid" class="grid-panel"></div>
            </div>
            <div class="results-actions">
                <button id="review-btn" class="btn btn-primary">ç­”é¢˜å›é¡¾</button>
                <button id="retry-btn" class="btn btn-success">é‡æ–°ç­”é¢˜</button>
                <button id="home-btn" class="btn btn-secondary">è¿”å›ä¸»é¡µ</button>
            </div>
        </div>
        
        <div id="review-screen" class="screen">
            <h2>ç­”é¢˜å›é¡¾</h2>
            <div id="review-filters">
                <div class="filter-group">
                    <label>çŠ¶æ€:</label>
                    <div id="filter-correctness" class="tab-filter"></div>
                </div>
                <div class="filter-group">
                    <label>é¢˜å‹:</label>
                    <div id="filter-type" class="tab-filter"></div>
                </div>
            </div>
            <div id="review-container"></div>
            <div class="results-actions" style="margin-top: 2rem;">
                 <button id="back-to-results-btn" class="btn btn-primary">è¿”å›ç»“æœ</button>
            </div>
        </div>
    </div>
    
    <div id="overlay" class="overlay"></div>
    <div id="nav-panel">
        <div id="nav-panel-header">
            <h3>é¢˜ç›®å¯¼èˆª</h3>
            <button id="close-nav-btn">&times;</button>
        </div>
        <div id="nav-grid" class="grid-panel"></div>
    </div>

    <div id="tooltip"></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // ADDED: ä¸»é¢˜åˆ‡æ¢é€»è¾‘
    const themeSwitcher = document.getElementById('theme-switcher');
    const themeIcon = document.getElementById('theme-icon');
    const body = document.body;

    const applyTheme = (theme) => {
        if (theme === 'dark') {
            body.classList.add('dark-mode');
            themeIcon.textContent = 'â˜€ï¸';
        } else {
            body.classList.remove('dark-mode');
            themeIcon.textContent = 'ğŸŒ™';
        }
    };

    // é¡µé¢åŠ è½½æ—¶åº”ç”¨ä¿å­˜çš„ä¸»é¢˜
    const savedTheme = localStorage.getItem('quizTheme') || 'light';
    applyTheme(savedTheme);

    themeSwitcher.addEventListener('click', () => {
        const currentTheme = body.classList.contains('dark-mode') ? 'light' : 'dark';
        localStorage.setItem('quizTheme', currentTheme);
        applyTheme(currentTheme);
    });


    // --- å…¨å±€çŠ¶æ€å˜é‡ ---
    let workbook;
    let headers = [];
    let fullQuizData = []; // The complete question bank from Excel
    let quizData = []; // The active set of questions for the current quiz
    let currentQuestionIndex = 0;
    let userAnswers = []; // Stores user's answers for each question
    let questionResults = []; // Array of booleans indicating correctness for quiz mode
    let quizSettings = {};
    let currentFilters = { correctness: 'all', type: 'all' };

    const MAPPING_CONFIG = {
        question: { label: 'é¢˜å¹²', required: true },
        type: { label: 'é¢˜å‹', required: true },
        answer: { label: 'ç­”æ¡ˆ', required: true },
        optionA: { label: 'é€‰é¡¹A', required: false },
        optionB: { label: 'é€‰é¡¹B', required: false },
        optionC: { label: 'é€‰é¡¹C', required: false },
        optionD: { label: 'é€‰é¡¹D', required: false },
        optionE: { label: 'é€‰é¡¹E', required: false },
        optionF: { label: 'é€‰é¡¹F', required: false },
        explanation: { label: 'è§£æ', required: false },
    };

    // --- DOM å…ƒç´ è·å– ---
    const screens = {
        upload: document.getElementById('upload-screen'),
        quiz: document.getElementById('quiz-screen'),
        results: document.getElementById('results-screen'),
        review: document.getElementById('review-screen'),
    };
    
    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    const fileNameDisplay = document.getElementById('file-name');
    const configPanel = document.getElementById('config-panel');
    const sheetSelect = document.getElementById('sheet-select');
    const headerMappingContainer = document.getElementById('header-mapping');
    const startBtn = document.getElementById('start-btn');

    const progressText = document.getElementById('progress-text');
    const progressIndicator = document.getElementById('progress-indicator');
    const questionText = document.getElementById('question-text');
    const questionTypeBadge = document.getElementById('question-type-badge');
    const optionsContainer = document.getElementById('options-container');
    const feedbackBox = document.getElementById('feedback-box');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const submitBtn = document.getElementById('submit-btn');
    
    const scoreDisplay = document.getElementById('score');
    const accuracyDisplay = document.getElementById('accuracy');
    const resultsGrid = document.getElementById('results-grid');
    const reviewBtn = document.getElementById('review-btn');
    const retryBtn = document.getElementById('retry-btn');
    const homeBtn = document.getElementById('home-btn');
    
    const reviewContainer = document.getElementById('review-container');
    const backToResultsBtn = document.getElementById('back-to-results-btn');
    const filterCorrectness = document.getElementById('filter-correctness');
    const filterType = document.getElementById('filter-type');

    const exitQuizBtn = document.getElementById('exit-quiz-btn');
    const hintBtn = document.getElementById('hint-btn');
    const navToggleBtn = document.getElementById('nav-toggle-btn');
    const navPanel = document.getElementById('nav-panel');
    const navGrid = document.getElementById('nav-grid');
    const closeNavBtn = document.getElementById('close-nav-btn');
    const overlay = document.getElementById('overlay');
    const tooltip = document.getElementById('tooltip');
    
    // --- é¡µé¢åˆ‡æ¢é€»è¾‘ ---
    function showScreen(screenName) {
        Object.values(screens).forEach(s => s.classList.remove('active'));
        screens[screenName].classList.add('active');
    }

    // --- æ–‡ä»¶ä¸Šä¼ ä¸è§£æ ---
    uploadArea.addEventListener('click', () => fileInput.click());
    ['dragover', 'dragleave', 'drop'].forEach(eventName => {
        uploadArea.addEventListener(eventName, (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (eventName === 'dragover') uploadArea.classList.add('hover');
            if (eventName === 'dragleave') uploadArea.classList.remove('hover');
            if (eventName === 'drop') {
                uploadArea.classList.remove('hover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    fileInput.files = files;
                    handleFile(files[0]);
                }
            }
        });
    });
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) handleFile(file);
    });

    function handleFile(file) {
        fileNameDisplay.textContent = `å·²é€‰æ‹©æ–‡ä»¶: ${file.name}`;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = new Uint8Array(e.target.result);
                workbook = XLSX.read(data, { type: 'array' });
                populateSheetSelect();
                configPanel.style.display = 'block';
            } catch (error) {
                console.error("Error parsing Excel file:", error);
                alert("æ–‡ä»¶è§£æå¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®ï¼");
            }
        };
        reader.readAsArrayBuffer(file);
    }
    
    function populateSheetSelect() {
        sheetSelect.innerHTML = '';
        workbook.SheetNames.forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            sheetSelect.appendChild(option);
        });
        sheetSelect.dispatchEvent(new Event('change'));
    }
    
    sheetSelect.addEventListener('change', () => {
        const sheetName = sheetSelect.value;
        const worksheet = workbook.Sheets[sheetName];
        const aoa = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval:"" });
        headers = aoa[0] || [];
        populateHeaderMapping();
        validateConfig();
    });

    function populateHeaderMapping() {
        headerMappingContainer.innerHTML = '';
        Object.entries(MAPPING_CONFIG).forEach(([key, value]) => {
            const label = document.createElement('label');
            label.htmlFor = `map-${key}`;
            label.textContent = `${value.label}${value.required ? ' *' : ''}`;
            
            const select = document.createElement('select');
            select.id = `map-${key}`;
            select.dataset.key = key;
            select.innerHTML = `<option value="">-- è¯·é€‰æ‹© --</option>`;
            headers.forEach((header) => {
                if(header){
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    // Try to auto-select matching headers
                    if (header.trim().includes(value.label) || header.trim().toLowerCase() === key.toLowerCase()) {
                         option.selected = true;
                    }
                    select.appendChild(option);
                }
            });
            select.addEventListener('change', validateConfig);
            
            headerMappingContainer.appendChild(label);
            headerMappingContainer.appendChild(select);
        });
    }

    function validateConfig() {
        let isValid = true;
        const selects = headerMappingContainer.querySelectorAll('select');
        selects.forEach(select => {
            const key = select.dataset.key;
            if (MAPPING_CONFIG[key].required && !select.value) {
                isValid = false;
            }
        });
        startBtn.disabled = !isValid;
    }

    // --- å¯åŠ¨ç­”é¢˜ ---
    startBtn.addEventListener('click', () => {
        captureQuizSettings();
        processExcelData();
        startQuiz();
    });
    
    function startQuiz() {
        if (fullQuizData.length === 0) {
            alert("æ— æ³•ç”Ÿæˆé¢˜åº“ï¼Œè¯·æ£€æŸ¥Excelå†…å®¹æˆ–è¡¨å¤´æ˜ å°„æ˜¯å¦æ­£ç¡®ï¼");
            return;
        }

        let dataPool = [...fullQuizData];
        if (quizSettings.orderMode === 'random') {
            dataPool.sort(() => Math.random() - 0.5);
        }
        
        if (quizSettings.limit > 0 && dataPool.length > quizSettings.limit) {
            quizData = dataPool.slice(0, quizSettings.limit);
        } else {
            quizData = dataPool;
        }

        userAnswers = new Array(quizData.length).fill(null);
        questionResults = []; // Reset results for new quiz
        currentQuestionIndex = 0;
        showScreen('quiz');
        renderQuestion();
        renderNavPanel();
    }

    function captureQuizSettings() {
        quizSettings = {
            mainMode: document.querySelector('input[name="mainMode"]:checked').value,
            orderMode: document.getElementById('order-mode-select').value,
            limit: parseInt(document.getElementById('quiz-limit').value, 10),
            judgementTrue: document.getElementById('judgement-true').value || 'æ­£ç¡®',
            judgementFalse: document.getElementById('judgement-false').value || 'é”™è¯¯'
        };
    }

    function processExcelData() {
        const sheetName = sheetSelect.value;
        const worksheet = workbook.Sheets[sheetName];
        // Use {raw: false} to preserve formatted text (e.g., dates as strings)
        const jsonData = XLSX.utils.sheet_to_json(worksheet, {raw: false, defval:""});

        const mapping = {};
        headerMappingContainer.querySelectorAll('select').forEach(s => {
            if(s.value) mapping[s.dataset.key] = s.value;
        });

        fullQuizData = jsonData.map((row, index) => {
            const question = {
                originalIndex: index, // Keep track of original row for review
                text: row[mapping.question]?.toString() || '',
                type: row[mapping.type]?.toString().trim() || '',
                answer: row[mapping.answer]?.toString().trim() || '',
                options: [],
                explanation: row[mapping.explanation]?.toString() || ''
            };

            // Process options for multiple choice/single choice questions
            ['optionA', 'optionB', 'optionC', 'optionD', 'optionE', 'optionF'].forEach(optKey => {
                if (mapping[optKey] && (row[mapping[optKey]] !== undefined && row[mapping[optKey]] !== null && row[mapping[optKey]] !== '')) {
                    question.options.push(row[mapping[optKey]].toString());
                }
            });

            return question;
        }).filter(q => q.text && q.type && q.answer); // Ensure essential fields exist
    }

    // --- ç­”é¢˜é€»è¾‘ ---
    function renderQuestion() {
        if (currentQuestionIndex < 0 || currentQuestionIndex >= quizData.length) return;

        const q = quizData[currentQuestionIndex];
        questionText.textContent = `${currentQuestionIndex + 1}. ${q.text}`;
        questionTypeBadge.textContent = q.type;
        optionsContainer.innerHTML = '';
        feedbackBox.style.display = 'none';

        const savedAnswer = userAnswers[currentQuestionIndex];
        // MODIFIED: èƒŒé¢˜æ¨¡å¼ä¸‹éšè—æç¤ºæŒ‰é’®
        hintBtn.style.display = quizSettings.mainMode === 'recite' ? 'none' : 'inline-block';

        switch (q.type) {
            case 'å•é€‰é¢˜':
                renderChoiceQuestion('radio', q, savedAnswer);
                break;
            case 'åˆ¤æ–­é¢˜':
                // Use custom true/false options for judgement questions
                const customOptions = [quizSettings.judgementTrue, quizSettings.judgementFalse];
                renderChoiceQuestion('radio', {...q, options: customOptions}, savedAnswer);
                break;
            case 'å¤šé€‰é¢˜':
                renderChoiceQuestion('checkbox', q, savedAnswer);
                break;
            case 'å¡«ç©ºé¢˜':
                renderFillInQuestion(q, savedAnswer);
                break;
            default:
                optionsContainer.innerHTML = '<p>ä¸æ”¯æŒçš„é¢˜å‹ã€‚</p>';
        }

        // ADDED: èƒŒé¢˜æ¨¡å¼é€»è¾‘
        if (quizSettings.mainMode === 'recite') {
            showImmediateFeedback(q, null, true); // ç›´æ¥æ˜¾ç¤ºç­”æ¡ˆ
            disableAllInputs(); // ç¦ç”¨æ‰€æœ‰è¾“å…¥
        } else if (quizSettings.mainMode === 'review' && savedAnswer !== null) {
            // In review mode, if there's a saved answer, show feedback
            showImmediateFeedback(q, savedAnswer);
        }


        updateQuizNav();
        updateProgress();
        updateNavPanel();
    }

    function renderChoiceQuestion(type, q, savedAnswer) {
        q.options.forEach((opt, index) => {
            const id = `q${currentQuestionIndex}-opt${index}`;
            const label = document.createElement('label');
            label.className = 'option';
            label.htmlFor = id;
            
            const input = document.createElement('input');
            input.type = type;
            input.name = `q${currentQuestionIndex}`;
            input.id = id;
            input.value = String.fromCharCode(65 + index); // A, B, C...
            
            if (type === 'radio' && savedAnswer === input.value) input.checked = true;
            if (type === 'checkbox' && savedAnswer && savedAnswer.includes(input.value)) input.checked = true;
            
            input.addEventListener('change', saveAnswer);

            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${input.value}. ${opt}`));
            optionsContainer.appendChild(label);
        });
    }

    // FIX: å¡«ç©ºé¢˜bugä¿®å¤ (æ— æ³•è¾“å…¥åŠç­”æ¡ˆæ— æ³•æ˜¾ç¤º)
    function renderFillInQuestion(q, savedAnswer) {
        const container = document.createElement('div');
        container.className = 'fill-in-container';
        
        // Correctly split the expected answer for blanks
        const correctAnswers = q.answer.split('|||'); 
        const savedAnswers = savedAnswer ? savedAnswer.split('|||') : [];
        const numBlanks = correctAnswers.length;

        for (let i = 0; i < numBlanks; i++) {
            const input = document.createElement('input');
            input.type = 'text';
            input.dataset.blankIndex = i; // Add data attribute to maintain order
            input.placeholder = numBlanks > 1 ? `è¯·å¡«å†™ç¬¬ ${i + 1} ä¸ªç­”æ¡ˆ` : 'è¯·å¡«å†™ç­”æ¡ˆ';
            // Pre-fill with saved answer if available
            if (savedAnswers[i] !== undefined) {
                input.value = savedAnswers[i];
            }
            // Use 'input' event for real-time saving
            input.addEventListener('input', saveAnswer); 
            container.appendChild(input);
        }
        
        optionsContainer.appendChild(container);
    }
    
    function saveAnswer() {
        const q = quizData[currentQuestionIndex];
        let currentAnswer;
        switch(q.type) {
            case 'å•é€‰é¢˜':
            case 'åˆ¤æ–­é¢˜':
                const checkedRadio = optionsContainer.querySelector('input[type="radio"]:checked');
                currentAnswer = checkedRadio ? checkedRadio.value : null;
                break;
            case 'å¤šé€‰é¢˜':
                const checkedBoxes = Array.from(optionsContainer.querySelectorAll('input[type="checkbox"]:checked'));
                currentAnswer = checkedBoxes.map(cb => cb.value).sort().join('');
                // If no boxes checked, set to null/empty string for easier checking
                if (currentAnswer === '') currentAnswer = null; 
                break;
            case 'å¡«ç©ºé¢˜':
                // FIX: Retrieve fill-in answers in order
                const inputs = Array.from(optionsContainer.querySelectorAll('.fill-in-container input[type="text"]'));
                inputs.sort((a, b) => parseInt(a.dataset.blankIndex) - parseInt(b.dataset.blankIndex)); // Sort by index
                currentAnswer = inputs.map(input => input.value.trim()).join('|||');
                // If all blanks are empty, consider it unanswered
                if (currentAnswer.replace(/\|/g, '').trim() === '') currentAnswer = null; 
                break;
            default:
                currentAnswer = null;
        }
        userAnswers[currentQuestionIndex] = currentAnswer;
        
        if (quizSettings.mainMode === 'review') {
            // In review mode, immediately update feedback when answer changes
            showImmediateFeedback(q, currentAnswer);
        }
        updateNavPanel(); // Update navigation panel (e.g., mark as answered)
    }

    // MODIFIED: ç»Ÿä¸€çš„åé¦ˆæ˜¾ç¤ºå‡½æ•°ï¼Œæ”¯æŒèƒŒé¢˜æ¨¡å¼å’Œé”™è¯¯åé¦ˆ
    function showImmediateFeedback(q, userAnswer, isHint = false) {
        // Temporarily check answer for hints, don't save result
        const { isCorrect, correctAnswerText } = checkAnswer(q, userAnswer, isHint);
        
        feedbackBox.style.display = 'block';
        if (isHint) {
            // For hint mode (or recite mode), always show correct answer and explanation
            feedbackBox.className = 'feedback-box hint';
            feedbackBox.innerHTML = `
                <p><strong>æ­£ç¡®ç­”æ¡ˆ:</strong> ${correctAnswerText}</p>
                ${q.explanation ? `<p><strong>è§£æ:</strong> ${q.explanation}</p>` : ''}
            `;
        } else {
            // For quiz/review mode, show correctness feedback
            feedbackBox.className = `feedback-box ${isCorrect ? 'correct' : 'incorrect'}`;
            feedbackBox.innerHTML = `
                <p><strong>${isCorrect ? 'å›ç­”æ­£ç¡®ï¼' : 'å›ç­”é”™è¯¯ã€‚'}</strong></p>
                <p>æ­£ç¡®ç­”æ¡ˆ: ${correctAnswerText}</p>
                ${q.explanation ? `<p><strong>è§£æ:</strong> ${q.explanation}</p>` : ''}
            `;
        }
    }

    function updateQuizNav() {
        const isLastQuestion = currentQuestionIndex === quizData.length - 1;
        prevBtn.disabled = currentQuestionIndex === 0;
        
        // MODIFIED: å¯¼èˆªæŒ‰é’®æ˜¾ç¤ºé€»è¾‘ï¼Œé€‚é…èƒŒé¢˜æ¨¡å¼
        // 'Next' button typically visible until the last question
        nextBtn.style.display = isLastQuestion ? 'none' : 'inline-block';
        // 'Submit' button only appears on the last question AND not in recite mode
        submitBtn.style.display = (isLastQuestion && quizSettings.mainMode !== 'recite') ? 'inline-block' : 'none';
    }
    
    function updateProgress() {
        progressText.textContent = `è¿›åº¦: ${currentQuestionIndex + 1} / ${quizData.length}`;
        const percentage = ((currentQuestionIndex + 1) / quizData.length) * 100;
        progressIndicator.style.width = `${percentage}%`;
    }

    prevBtn.addEventListener('click', () => {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            renderQuestion();
        }
    });

    nextBtn.addEventListener('click', () => {
        if (currentQuestionIndex < quizData.length - 1) {
            currentQuestionIndex++;
            renderQuestion();
        }
    });
    
    submitBtn.addEventListener('click', () => {
        // In "Review mode", allow submission even if not all questions are answered
        if (quizSettings.mainMode === 'review') {
            calculateResults();
            return;
        }
        // In "Quiz mode", check for unanswered questions
        const unAnsweredCount = userAnswers.filter(a => a === null || (typeof a === 'string' && a.replace(/\|{3}/g, '').trim() === '')).length;
        if (unAnsweredCount > 0) {
            if (!confirm(`è¿˜æœ‰ ${unAnsweredCount} é¢˜æœªä½œç­”ï¼Œç¡®å®šè¦æäº¤å—ï¼Ÿ`)) {
                return;
            }
        }
        calculateResults();
    });
    
    // ADDED: æ–°å¢è¾…åŠ©å‡½æ•°ï¼Œç”¨äºç¦ç”¨æ‰€æœ‰è¾“å…¥
    function disableAllInputs() {
        const inputs = optionsContainer.querySelectorAll('input, select, textarea');
        inputs.forEach(input => {
            input.disabled = true;
            const parentLabel = input.closest('label'); // For radio/checkbox options
            if (parentLabel) {
                parentLabel.style.cursor = 'default';
                parentLabel.style.opacity = '0.7';
                parentLabel.style.pointerEvents = 'none'; // Prevents label click
            } else if (input.type === 'text') { // For fill-in inputs
                input.style.opacity = '0.7';
                input.style.pointerEvents = 'none';
            }
        });
    }

    // MODIFIED: ç­”æ¡ˆæ£€æŸ¥é€»è¾‘ï¼Œæ”¯æŒå¤šç§é¢˜å‹ï¼Œè€ƒè™‘å¤§å°å†™ç­‰
    function checkAnswer(q, userAnswer, isHintCheck = false) {
        let isCorrect = false;
        let correctAnswerText = '';

        // Helper to get option content based on letter (e.g., 'A', 'B')
        const getOptionContent = (letter) => {
            const index = letter.charCodeAt(0) - 65;
            if (q.type === 'åˆ¤æ–­é¢˜') {
                const customOptions = [quizSettings.judgementTrue, quizSettings.judgementFalse];
                return customOptions[index] || '';
            }
            return q.options[index] || '';
        };

        const normalizeChoiceAnswer = (answer) => {
            if (!answer) return "";
            return answer.replace(/[,ï¼Œ\s]/g, '').toUpperCase().split('').sort().join('');
        };

        switch (q.type) {
            case 'å•é€‰é¢˜':
                isCorrect = (userAnswer === q.answer.toUpperCase());
                correctAnswerText = `${q.answer.toUpperCase()}. ${getOptionContent(q.answer.toUpperCase())}`;
                break;
            case 'åˆ¤æ–­é¢˜': {
                const customOptions = [quizSettings.judgementTrue, quizSettings.judgementFalse];
                let correctLetter = '';
                const normalizedAnswerFromExcel = q.answer.trim().toLowerCase();
                
                if (normalizedAnswerFromExcel === customOptions[0].toLowerCase() || normalizedAnswerFromExcel === 'a') {
                    correctLetter = 'A';
                    correctAnswerText = `${correctLetter}. ${customOptions[0]}`;
                } else if (normalizedAnswerFromExcel === customOptions[1].toLowerCase() || normalizedAnswerFromExcel === 'b') {
                    correctLetter = 'B';
                    correctAnswerText = `${correctLetter}. ${customOptions[1]}`;
                } else {
                    // Fallback if Excel answer is not "æ­£ç¡®/é”™è¯¯" or "A/B"
                    correctAnswerText = q.answer; 
                }
                isCorrect = (userAnswer === correctLetter);
                break;
            }
            case 'å¤šé€‰é¢˜': {
                const sortedUserAnswer = normalizeChoiceAnswer(userAnswer);
                const sortedCorrectAnswer = normalizeChoiceAnswer(q.answer);
                isCorrect = (sortedUserAnswer === sortedCorrectAnswer);
                correctAnswerText = sortedCorrectAnswer.split('').map(letter => `${letter}. ${getOptionContent(letter)}`).join('<br>'); // Use <br> for multi-line display
                break;
            }
            case 'å¡«ç©ºé¢˜':
                // FIX: Fill-in answer comparison is now case-insensitive and robust
                const userAnswersTrimmed = (userAnswer || '').split('|||').map(a => a.trim().toLowerCase());
                const correctAnswersTrimmed = q.answer.split('|||').map(a => a.trim().toLowerCase());
                
                isCorrect = userAnswersTrimmed.length === correctAnswersTrimmed.length &&
                            userAnswersTrimmed.every((val, idx) => val === correctAnswersTrimmed[idx]);
                
                // FORMATTED: Correct answer text for display
                correctAnswerText = q.answer.split('|||').join(', '); 
                break;
            default:
                isCorrect = false;
                correctAnswerText = 'N/A';
        }
        return { isCorrect, correctAnswerText };
    }

    function calculateResults() {
        let score = 0;
        questionResults = []; // Clear previous results
        
        quizData.forEach((q, index) => {
            const userAnswer = userAnswers[index];
            const { isCorrect } = checkAnswer(q, userAnswer); // Use the unified checkAnswer
            questionResults.push(isCorrect);
            if (isCorrect) {
                score++;
            }
        });
        
        const total = quizData.length;
        const accuracy = total > 0 ? (score / total * 100).toFixed(1) : 0;
        
        scoreDisplay.textContent = `${score} / ${total} åˆ†`;
        accuracyDisplay.textContent = `æ­£ç¡®ç‡: ${accuracy}%`;
        
        renderResultsGrid();
        reviewBtn.style.display = 'block'; // Ensure review button is visible

        showScreen('results');
    }

    function renderResultsGrid() {
        resultsGrid.innerHTML = '';
        questionResults.forEach((isCorrect, index) => {
            const btn = document.createElement('button');
            btn.className = `grid-btn ${isCorrect ? 'correct' : 'incorrect'}`;
            btn.textContent = index + 1;
            btn.dataset.index = index;
            // Only make incorrect questions clickable for review
            if (!isCorrect) {
                // ADDED: Click on incorrect question in results grid to jump to review
                btn.addEventListener('click', () => jumpToReview(index));
            }
            btn.addEventListener('mouseenter', handleTooltipShow);
            btn.addEventListener('mouseleave', handleTooltipHide);
            resultsGrid.appendChild(btn);
        });
    }
    
    // ADDED: Jump to a specific question in review mode
    function jumpToReview(questionIndex) {
        currentFilters.correctness = 'incorrect'; // If jumping from incorrect via grid, filter incorrect
        currentFilters.type = 'all'; // Reset type filter
        populateReviewFilterTypes(); // Update filter UI
        renderReview(); // Re-render review questions
        showScreen('review'); // Show review screen
        // Scroll to the specific question
        setTimeout(() => { // Use setTimeout to ensure element is rendered
            const reviewItem = document.getElementById(`review-item-${questionIndex}`);
            if(reviewItem) {
                reviewItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 100);
    }

    // --- ç­”é¢˜å›é¡¾ ---
    reviewBtn.addEventListener('click', () => {
        // Reset filters when entering review from results
        currentFilters = { correctness: 'all', type: 'all' };
        populateReviewFilterTypes(); // Initialize filters
        renderReview();
        showScreen('review');
    });
    
    function createFilterTabs(container, filterKey, options) {
        container.innerHTML = '';
        options.forEach(option => {
            const btn = document.createElement('button');
            btn.textContent = option.text;
            btn.dataset.value = option.value;
            if (currentFilters[filterKey] === option.value) {
                btn.classList.add('active');
            }
            btn.addEventListener('click', () => {
                currentFilters[filterKey] = option.value;
                renderReview(); // Re-render review when filter changes
            });
            container.appendChild(btn);
        });
    }

    function populateReviewFilterTypes() {
        const correctnessOptions = [
            { text: 'å…¨éƒ¨', value: 'all' },
            { text: 'æ­£ç¡®', value: 'correct' },
            { text: 'é”™è¯¯', value: 'incorrect' },
        ];
        createFilterTabs(filterCorrectness, 'correctness', correctnessOptions);

        const questionTypes = [...new Set(quizData.map(q => q.type))];
        const typeOptions = [{ text: 'æ‰€æœ‰ç±»å‹', value: 'all' }];
        questionTypes.forEach(type => typeOptions.push({ text: type, value: type }));
        createFilterTabs(filterType, 'type', typeOptions);
    }
    
    function renderReview() {
        populateReviewFilterTypes(); // Ensure filters are updated
        reviewContainer.innerHTML = '';
        let questionsFound = 0;

        quizData.forEach((q, index) => {
            const isCorrect = questionResults[index];
            
            // Apply correctness filter
            if (currentFilters.correctness === 'correct' && !isCorrect) return;
            if (currentFilters.correctness === 'incorrect' && isCorrect) return;
            
            // Apply type filter
            if (currentFilters.type !== 'all' && q.type !== currentFilters.type) return;

            questionsFound++;
            const item = document.createElement('div');
            item.className = `review-item ${isCorrect ? 'review-item-correct' : 'review-item-incorrect'}`;
            item.id = `review-item-${index}`; // Add an ID for scrolling
            
            const userAnswer = userAnswers[index];
            const { correctAnswerText } = checkAnswer(q, userAnswer); // Get formatted correct answer

            const title = document.createElement('p');
            title.innerHTML = `<strong>${index + 1}. ${q.text}</strong> <span class="question-type-badge">${q.type}</span>`;
            item.appendChild(title);

            if (q.type !== 'å¡«ç©ºé¢˜') {
                const optionsGrid = document.createElement('div');
                optionsGrid.className = 'review-options-grid';
                
                let optionsToShow = q.options;
                if (q.type === 'åˆ¤æ–­é¢˜') {
                    optionsToShow = [quizSettings.judgementTrue, quizSettings.judgementFalse];
                }

                let correctAnswerLetters = normalizeAnswer(q.answer);
                if (q.type === 'åˆ¤æ–­é¢˜') {
                    // Logic to get correct letter for judgement questions
                    const customOptions = [quizSettings.judgementTrue, quizSettings.judgementFalse];
                    const normalizedExcelAnswer = q.answer.trim().toLowerCase();
                    if (normalizedExcelAnswer === customOptions[0].toLowerCase() || normalizedExcelAnswer === 'a') {
                        correctAnswerLetters = 'A';
                    } else if (normalizedExcelAnswer === customOptions[1].toLowerCase() || normalizedExcelAnswer === 'b') {
                        correctAnswerLetters = 'B';
                    } else {
                        correctAnswerLetters = ''; // Unknown judgement answer
                    }
                }

                optionsToShow.forEach((opt, optIndex) => {
                    const optLetter = String.fromCharCode(65 + optIndex);
                    const card = document.createElement('div');
                    card.className = 'review-option-card';
                    
                    const isUserSelected = userAnswer ? userAnswer.includes(optLetter) : false;
                    const isCorrectOption = correctAnswerLetters.includes(optLetter);

                    if (isCorrectOption) card.classList.add('correct-option');
                    // Only mark user's incorrect selections (not just correct selections that also happen to be user selected)
                    else if (isUserSelected && !isCorrectOption) card.classList.add('user-selected-incorrect');

                    const optionText = document.createElement('span');
                    optionText.textContent = `${optLetter}. ${opt}`;
                    card.appendChild(optionText);

                    if (isUserSelected) {
                        const userTag = document.createElement('span');
                        userTag.className = 'review-user-choice-tag';
                        userTag.textContent = 'æ‚¨çš„é€‰æ‹©';
                        card.appendChild(userTag);
                    }
                    optionsGrid.appendChild(card);
                });
                item.appendChild(optionsGrid);

            } else { // FIX: Fill-in question review display
                const answerContainer = document.createElement('div');
                answerContainer.style.marginTop = '1rem';
                
                const userAnswersSplit = (userAnswer || '').split('|||');
                const correctAnswersSplit = q.answer.split('|||');

                const yourAnswerP = document.createElement('p');
                yourAnswerP.innerHTML = '<strong>ä½ çš„ç­”æ¡ˆ:</strong> ';
                
                if (!userAnswer || userAnswer.replace(/\|/g, '').trim() === '') {
                     yourAnswerP.innerHTML += '<span style="color: var(--text-color-muted);">(æœªä½œç­”)</span>';
                } else {
                    userAnswersSplit.forEach((ans, i) => {
                        const ansSpan = document.createElement('span');
                        ansSpan.textContent = ans.trim() || '(æœªå¡«å†™)';
                        ansSpan.style.display = 'inline-block';
                        ansSpan.style.padding = '2px 8px';
                        ansSpan.style.borderRadius = '4px';
                        ansSpan.style.margin = '2px 4px 2px 0';
                        ansSpan.style.border = '1px solid';
                        ansSpan.style.fontWeight = '500';

                        // Case-insensitive comparison for fill-in answers
                        if (ans.trim().toLowerCase() === (correctAnswersSplit[i] || '').trim().toLowerCase()) {
                            ansSpan.style.backgroundColor = 'color-mix(in srgb, var(--success-color) 20%, transparent)';
                            ansSpan.style.borderColor = 'var(--success-color)';
                        } else {
                            ansSpan.style.backgroundColor = 'color-mix(in srgb, var(--danger-color) 20%, transparent)';
                            ansSpan.style.borderColor = 'var(--danger-color)';
                        }
                        yourAnswerP.appendChild(ansSpan);
                    });
                }

                const correctAnswerP = document.createElement('p');
                correctAnswerP.innerHTML = `<strong>æ­£ç¡®ç­”æ¡ˆ:</strong> ${
                    correctAnswersSplit.map(ans => `<span style="display:inline-block; padding: 2px 8px; border-radius: 4px; margin: 2px 4px 2px 0; background-color: color-mix(in srgb, var(--success-color) 20%, transparent); border: 1px solid var(--success-color); font-weight: 500;">${ans.trim()}</span>`).join('')
                }`;
                correctAnswerP.style.marginTop = '0.5rem';

                answerContainer.appendChild(yourAnswerP);
                answerContainer.appendChild(correctAnswerP);
                item.appendChild(answerContainer);
            }

            if (q.explanation) {
                const explanationEl = document.createElement('p');
                explanationEl.innerHTML = `<strong>è§£æ:</strong> ${q.explanation}`;
                explanationEl.style.marginTop = '1rem';
                item.appendChild(explanationEl);
            }

            reviewContainer.appendChild(item);
        });
        
        if (questionsFound === 0) {
            reviewContainer.innerHTML = '<p style="text-align:center; color: var(--text-color-muted);">æ²¡æœ‰ç¬¦åˆç­›é€‰æ¡ä»¶çš„é¢˜ç›®ã€‚</p>';
        }
    }
    
    backToResultsBtn.addEventListener('click', () => showScreen('results'));

    function resetApp() {
        workbook = null; headers = []; fullQuizData = []; quizData = [];
        currentQuestionIndex = 0; userAnswers = []; questionResults = []; quizSettings = {};
        
        fileInput.value = '';
        fileNameDisplay.textContent = '';
        configPanel.style.display = 'none';
        startBtn.disabled = true;

        showScreen('upload');
    }
    homeBtn.addEventListener('click', resetApp);
    retryBtn.addEventListener('click', startQuiz);
    exitQuizBtn.addEventListener('click', () => {
        // MODIFIED: èƒŒé¢˜æ¨¡å¼ä¸‹é€€å‡ºæ— éœ€ç¡®è®¤
        if (quizSettings.mainMode === 'recite' || confirm('ç¡®å®šè¦é€€å‡ºå½“å‰ç­”é¢˜å—ï¼Ÿè¿›åº¦å°†ä¸ä¼šè¢«ä¿å­˜ã€‚')) {
            resetApp();
        }
    });

    hintBtn.addEventListener('click', () => {
        const q = quizData[currentQuestionIndex];
        showImmediateFeedback(q, null, true); // Pass true to show as hint
    });

    // MODIFIED: Tooltip content generation has been improved for all question types
    function handleTooltipShow(e) {
        const index = parseInt(e.target.dataset.index, 10);
        const q = quizData[index];
        const userAnswer = userAnswers[index];
        const { isCorrect } = checkAnswer(q, userAnswer); // Check correctness for display
        
        let optionsHTML = '';
        if (q.type !== 'å¡«ç©ºé¢˜') {
            let optionsToShow = q.options;
            if (q.type === 'åˆ¤æ–­é¢˜') {
                optionsToShow = [quizSettings.judgementTrue, quizSettings.judgementFalse];
            }
            
            let correctAnswerLetters = normalizeAnswer(q.answer);
            if (q.type === 'åˆ¤æ–­é¢˜') {
                const customOptions = [quizSettings.judgementTrue, quizSettings.judgementFalse];
                const normalizedExcelAnswer = q.answer.trim().toLowerCase();
                if (normalizedExcelAnswer === customOptions[0].toLowerCase() || normalizedExcelAnswer === 'a') {
                    correctAnswerLetters = 'A';
                } else if (normalizedExcelAnswer === customOptions[1].toLowerCase() || normalizedExcelAnswer === 'b') {
                    correctAnswerLetters = 'B';
                } else {
                    correctAnswerLetters = '';
                }
            }

            optionsToShow.forEach((opt, optIndex) => {
                const optLetter = String.fromCharCode(65 + optIndex);
                
                const isUserSelected = userAnswer ? userAnswer.includes(optLetter) : false;
                const isCorrectOption = correctAnswerLetters.includes(optLetter);
                
                let classList = 'tooltip-option-card';
                if (isCorrectOption) classList += ' correct-option';
                else if (isUserSelected && !isCorrectOption) classList += ' user-selected-incorrect';

                let userTagHTML = '';
                if (isUserSelected) userTagHTML = `<span class="tooltip-user-choice-tag">[æ‚¨çš„é€‰æ‹©]</span>`;

                optionsHTML += `<div class="${classList}"><span>${optLetter}. ${opt}</span> ${userTagHTML}</div>`;
            });
            optionsHTML = `<div class="tooltip-options-grid">${optionsHTML}</div>`;

        } else { // FIX: Tooltip for fill-in questions
            const { correctAnswerText } = checkAnswer(q, userAnswer); // Get full correct answer string

            const currentUserAnswers = (userAnswer || '').split('|||').map(a => a.trim());
            const correctAnswersForBlanks = q.answer.split('|||').map(a => a.trim());

            let userAnswersDisplay = currentUserAnswers.length > 0 && currentUserAnswers[0] !== ''
                ? currentUserAnswers.map((ans, i) => {
                    if (ans.toLowerCase() === (correctAnswersForBlanks[i] || '').toLowerCase()) {
                        return `<span style="color: var(--success-color);">${ans}</span>`;
                    } else if (ans === '') {
                        return `<span style="color: var(--text-color-muted);">(æœªå¡«å†™)</span>`;
                    } else {
                        return `<span style="color: var(--danger-color);">${ans}</span>`;
                    }
                }).join(', ')
                : '<span style="color: var(--text-color-muted);">æœªä½œç­”</span>';

            optionsHTML = `
                <p style="margin-top: 0.5rem;"><strong>æ‚¨çš„ç­”æ¡ˆ:</strong> ${userAnswersDisplay}</p>
                <p><strong>æ­£ç¡®ç­”æ¡ˆ:</strong> ${correctAnswerText}</p>
            `;
        }

        tooltip.innerHTML = `
            <p class="tooltip-question"><strong>${index + 1}. ${q.text}</strong></p>
            <p style="margin-top: 0.5rem;"><strong>ä½ çš„å›ç­”:</strong> ${isCorrect ? '<span style="color: var(--success-color);">æ­£ç¡®</span>' : '<span style="color: var(--danger-color);">é”™è¯¯</span>'}</p>
            ${optionsHTML}
        `;

        // Position tooltip
        const rect = e.target.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        let left = rect.right + 10;
        let top = rect.top;

        // Adjust if it goes off screen to the right
        if (left + tooltipRect.width > window.innerWidth - 20) {
            left = rect.left - tooltipRect.width - 10;
        }
        // Adjust if it goes off screen to the top
        if (top + tooltipRect.height > window.innerHeight - 20) {
            top = window.innerHeight - tooltipRect.height - 20;
        }
        if (top < 10) top = 10; // Ensure it doesn't go too high

        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
        tooltip.style.display = 'block';
    }

    function handleTooltipHide() {
        tooltip.style.display = 'none';
    }

    function toggleNavPanel(show) {
        navPanel.style.display = show ? 'flex' : 'none';
        overlay.style.display = show ? 'block' : 'none';
    }

    navToggleBtn.addEventListener('click', () => toggleNavPanel(true));
    closeNavBtn.addEventListener('click', () => toggleNavPanel(false));
    overlay.addEventListener('click', () => toggleNavPanel(false));

    function renderNavPanel() {
        navGrid.innerHTML = '';
        for (let i = 0; i < quizData.length; i++) {
            const btn = document.createElement('button');
            btn.className = 'grid-btn';
            btn.textContent = i + 1;
            btn.dataset.index = i;
            btn.addEventListener('click', () => {
                currentQuestionIndex = i;
                renderQuestion();
                toggleNavPanel(false);
            });
            navGrid.appendChild(btn);
        }
        updateNavPanel();
    }

    function updateNavPanel() {
        const buttons = navGrid.querySelectorAll('.grid-btn');
        buttons.forEach((btn, index) => {
            btn.classList.remove('current', 'answered'); // Remove previous states
            if (userAnswers[index] !== null) {
                // For fill-in questions, consider empty string (e.g., from "|||") as unanswered
                if (quizData[index].type === 'å¡«ç©ºé¢˜' && userAnswers[index].replace(/\|{3}/g, '').trim() === '') {
                     // Do nothing, not answered
                } else {
                    btn.classList.add('answered');
                }
            }
            if (index === currentQuestionIndex) {
                btn.classList.add('current');
            }
        });
    }

    // --- é”®ç›˜å¿«æ·é”® ---
    document.addEventListener('keydown', (e) => {
        if (screens.quiz.classList.contains('active')) {
            const activeEl = document.activeElement;
            // Allow typing in text inputs without triggering keyboard shortcuts
            if (activeEl && (activeEl.tagName === 'INPUT' && activeEl.type === 'text')) {
                // Only prevent default for navigation keys if in text input
                if (['ArrowLeft', 'ArrowRight', 'Enter', 'Tab'].includes(e.key)) {
                    e.preventDefault(); 
                }
                return; 
            }
            
            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    prevBtn.click();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (nextBtn.style.display !== 'none') {
                        nextBtn.click();
                    } else if (submitBtn.style.display !== 'none') {
                        submitBtn.click();
                    }
                    break;
                // MODIFIED: æ’é™¤èƒŒé¢˜æ¨¡å¼ä¸‹çš„å¿«æ·é”®é€‰æ‹©
                case 'a': case 'A': case '1': selectOption(0); break;
                case 'b': case 'B': case '2': selectOption(1); break;
                case 'c': case 'C': case '3': selectOption(2); break;
                case 'd': case 'D': case '4': selectOption(3); break;
                case 'e': case 'E': case '5': selectOption(4); break;
                case 'f': case 'F': case '6': selectOption(5); break;
            }
        }
    });

    function selectOption(index) {
        if (quizSettings.mainMode === 'recite') return; // Disable option selection in recite mode
        const q = quizData[currentQuestionIndex];
        if (q.type === 'å¡«ç©ºé¢˜') return; // Keyboard shortcuts not for fill-in

        const options = optionsContainer.querySelectorAll('input[type="radio"], input[type="checkbox"]');
        if (index < options.length) {
            if (options[index].type === 'radio') {
                options[index].checked = true;
            } else { // Checkbox
                options[index].checked = !options[index].checked;
            }
            saveAnswer();
        }
    }
});
</script>
</body>
</html>

